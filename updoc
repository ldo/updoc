#!/usr/bin/python3
#+
# Tool to maintain versions of a set of one or more related files
# in an SQLite database.
#-

import sys
import os
import stat
import enum
import re
import time
import fnmatch
import getopt
import apsw as sqlite

#+
# Database stuff
#-

class DB_OPEN(enum.IntEnum) :
    "database opening modes."
    READONLY = 0 # existing database, only for reading
    READWRITE = 1 # existing database, for reading and writing
    READWRITECREATE = 2 # create database if it doesn’t exist, open for reading and writing
#end DB_OPEN

def db_iter(conn, cmd, mapfn = lambda x : x) :
    "executes cmd on a new cursor from connection conn and yields the results in turn."
    for item in conn.cursor().execute(cmd) :
        yield mapfn(item)
    #end for
#end db_iter

class DIRKIND(enum.Enum) :
    "how to interpret file/dir specs in filter rules."
    ROOT = 0 # interpret as spec relative to root dir
    HASDIR = 1 # specs consist of parent dir followed by one or more child specs
    EVERYWHERE = 2 # interpret as spec relative to root dir and all subdirs
    ISDIR = 3 # spec is itself a dir of which all contained files are to be included
#end DIRKIND

class RULE_ACTION(enum.Enum) :
    "kinds of filter rules."
    INCLUDE = ("include", True, DIRKIND.ROOT, 0, None)
    EXCLUDE = ("exclude", False, DIRKIND.ROOT, 0, None)
    RECURSIVE_INCLUDE = \
        ("recursive-include", True, DIRKIND.HASDIR, 2,
            "required parent directory and at least one child filespec")
    RECURSIVE_EXCLUDE = \
        ("recursive-exclude", False, DIRKIND.HASDIR, 2,
            "required parent directory and at least one child filespec")
    GLOBAL_INCLUDE = ("global-include", True, DIRKIND.EVERYWHERE, 0, None)
    GLOBAL_EXCLUDE = ("global-exclude", False, DIRKIND.EVERYWHERE, 0, None)
    GRAFT = ("graft", True, DIRKIND.ISDIR, 0, None)
    PRUNE = ("prune", False, DIRKIND.ISDIR, 0, None)

    @property
    def keyword(self) :
        return self.value[0]
    #end keyword

    @property
    def include_matching(self) :
        "True to include matching items, False to exclude them."
        return self.value[1]
    #end include_matching

    @property
    def dirkind(self) :
        return self.value[2]
    #end dirkind

    @property
    def min_args(self) :
        "minimum number of pathspec args to this action."
        return self.value[3]
    #end min_args

    @property
    def msg_required_args(self) :
        "message to show for incorrect args."
        return self.value[4]
    #end msg_required_args

#end RULE_ACTION
RULE_ACTION.from_keyword = dict((i.keyword, i) for i in RULE_ACTION)

def open_db(dbname, mode) :
    "opens the specified database file and returns a new connection. mode is DB_OPEN value."
    test_table = "snapshots"
    test_field = "id"
    create_tables = \
        [
            "create table snapshots\n"
            "  (\n"
            "    id integer primary key autoincrement,\n"
            "    comment varchar not null,\n"
            "    timestamp double not null\n"
            "  )\n",
            "create table files\n"
            "  (\n"
            "    snapshot_id integer not null,\n" # = snapshots.id
            "    path varchar not null,\n"
            "    timestamp double not null,\n"
            "    contents blob not null,\n"
            "    primary key (snapshot_id, path)\n"
            "  )\n",
            "create table filter_rule\n"
            "  (\n"
            "    ordering integer primary key not null,\n" # for ordering of rules
            "    action varchar not null\n"
            "  )\n",
            "create table filter_item\n"
            "  (\n"
            "    rule_ordering integer not null,\n" # = filter_rule.filter_item
            "    item_ordering integer not null,\n" # for ordering of items within rule
            "    pathspec varchar not null,\n"
            "    primary key(rule_ordering, item_ordering)\n"
            "  )\n",
        ]
    result = \
        sqlite.Connection \
          (
            dbname,
            flags =
                    (sqlite.SQLITE_OPEN_READONLY, sqlite.SQLITE_OPEN_READWRITE)
                        [mode >= DB_OPEN.READWRITE]
                |
                    (0, sqlite.SQLITE_OPEN_CREATE)[mode == DB_OPEN.READWRITECREATE]
          )
    cu = result.cursor()
    try :
        cu.execute("select count(*) from %s where %s is not null" % (test_table, test_field))
        inited = True
    except sqlite.SQLError :
        if mode < DB_OPEN.READWRITECREATE :
            raise
        #end if
        # assume it’s a newly-created database, need to set up the tables
        inited = False
    #end try
    if not inited :
        sys.stderr.write("Initializing new database\n") # debug
        for create_table in create_tables :
            cu.execute(create_table)
        #end for
    #end if
    return \
        result
#end open_db_common

def parse_wildcard(parent, child) :
    # returns a compiled re.Pattern object that will match filenames
    # according to a given parent directory and child item pattern
    # that can contain shell-style wildcards.

    def parse_wildcard_path(s, default) :
        # returns an re.Pattern string that matches a given string that
        # can contain shell-style wildcards.
        if s != None :
            if s.startswith("/") :
                raise ValueError("relative pathspecs only")
            #end if
            t = ""
            i = 0
            cur_set = None
            while True :
                if i == len(s) :
                    if cur_set != None :
                        raise ValueError("incomplete “[...]” sequence")
                    #end if
                    break
                #end if
                c = s[i]
                i += 1
                if c == "\\" :
                    if i == len(s) :
                        raise ValueError("incomplete “\\” sequence")
                    #end if
                    c = s[i]
                    i += 1
                    if c == "n" :
                        c = "\n"
                    elif c == "t" :
                        c = "\t"
                    #end if
                    c = re.escape(c)
                elif cur_set == None and c == "*" :
                    if i < len(s) and s[i] == "*" :
                        i += 1
                        c = ".*" # can match “/”
                    else :
                        c = "[^\\/]*"
                    #end if
                elif cur_set == None and c == "?" :
                    c = "[^\\/]"
                elif cur_set == None and c == "[" :
                    cur_set = ""
                    c = None
                elif cur_set != None and len(cur_set) == 0 and c == "^" :
                    pass # include c as-is
                elif cur_set != None and c == "]" :
                    c = "[" + cur_set + "]"
                    cur_set = None
                else :
                    c = re.escape(c)
                #end if
                if c != None :
                    if cur_set != None :
                        cur_set += c
                    else :
                        t += c
                    #end if
                #end if
            #end while
        else :
            t = default
        #end if
        return \
            t
    #end parse_wildcard_path

#begin parse_wildcard
    if parent != None :
        while parent.endswith("/") :
            parent = parent[:-1]
        #end while
    #end if
    parent_pat = parse_wildcard_path(parent, "")
    child_pat = parse_wildcard_path(child, ".*")
    if parent_pat != "" :
        pat = parent_pat + "\\/(?:.+\\/)*" + child_pat
    else :
        pat = child_pat
    #end if
    if parent == None :
        # match filename anywhere in hierarchy
        pat = "(?:.+\\/)*" + pat
    #end if
    return \
        re.compile("^" + pat + "$", re.DOTALL)
#end parse_wildcard

def parse_manifest(contents) :
    "parses a string which has the format of the contents of a MANIFEST.in" \
    " file. Returns the tokenized filter rule text without further interpretation."

    def tokenize_line(s) :
        if "\t" in s :
            raise SyntaxError("no tabs allowed")
            # or I could fix parser to handle as part of whitespace
        #end if
        result = []
        cur_token = None
        while len(s) != 0 :
            pos1 = s.find("\\")
            pos2 = s.find(" ")
            if pos1 < 0 :
                pos1 = len(s)
            #end if
            if pos2 < 0 :
                pos2 = len(s)
            #end if
            if cur_token == None and pos2 != 0 :
                cur_token = ""
            #end if
            if pos1 < pos2 :
                if pos1 + 1 == len(s) :
                    raise ValueError("incomplete “\\” sequence")
                #end if
                cur_token += s[:pos1 + 2]
                s = s[pos1 + 2:]
            else : # pos2 < pos1
                if cur_token != None :
                    cur_token += s[:pos2]
                    result.append(cur_token)
                    cur_token = None
                #end if
                s = s[pos2 + 1:]
            #end if
        #end while
        return \
            result
    #end tokenize_line

#begin parse_manifest
    result = []
    for line in contents.split("\n") :
        line = line.lstrip()
        if not line.startswith("#") :
            items = tokenize_line(line)
            if len(items) != 0 :
                keyword = items[0]
                action = RULE_ACTION.from_keyword.get(keyword)
                if action == None :
                    raise ValueError("unrecognized rule keyword “%s”" % keyword)
                #end if
                if any(item.startswith("/") for item in items) :
                    raise ValueError("relative pathspecs only: “%s”" % line)
                #end if
                if len(items) < action.min_args + 1 :
                    raise ValueError("%s for %s" % (action.msg_required_args, keyword))
                #end if
                result.append(items)
            #end if
        #end if
    #end for
    return \
        result
#end parse_manifest

def escape_token(s) :
    "returns a quoted form of the token value s that can be fed back into" \
    " parse_manifest/tokenize_line."
    t = ""
    split = re.compile(r"([\\\t\n ])")
    remap = {"\t" : "t", "\n" : "n"}
    while True :
        s = re.split(split, s, 1)
        if len(s) == 1 :
            t += s[0]
            break
        #end if
        pre, ch, s = s
        ch = remap.get(ch, ch)
        t += pre + "\\" + ch
    #end while
    return t
#end escape_token

def load_filters(db) :
    "generator which loads the filter specs from the database."
    rules_iter = db_iter \
      (
        db,
        "select filter_rule.ordering, filter_item.item_ordering, filter_rule.action,"
        " filter_item.pathspec from filter_rule left join filter_item on"
        " filter_rule.ordering = filter_item.rule_ordering order by"
        " filter_rule.ordering, filter_item.item_ordering"
      )
    last_rule_index = None
    last_rule_action = None
    rule_items = None
    while True :
        item = next(rules_iter, None)
        if item != None :
            rule_index, item_index, rule_action, item_pathspec = item
        else :
            rule_index = None
        #end if
        if rule_index == None or rule_index != last_rule_index :
            if last_rule_index != None :
                yield (last_rule_action, rule_items)
                last_rule_index = None
            #end if
            if rule_index == None :
                break
            last_rule_index = rule_index
            last_rule_action = rule_action
            rule_items = []
        #end if
        if item_pathspec != None :
            rule_items.append(item_pathspec)
        #end if
    #end while
#end load_filters

def parse_filters(db) :
    "generator which loads and parses the filter specs from the database," \
    " yielding («include_matching», «match_pattern») pairs in order."
    for action, items in load_filters(db) :
        action = RULE_ACTION.from_keyword[action]
        to_parse = \
            {
                DIRKIND.ROOT : lambda item : ("", item),
                DIRKIND.HASDIR : lambda parent : lambda item : (parent, item),
                DIRKIND.EVERYWHERE : lambda item : (None, item),
                DIRKIND.ISDIR : lambda item : (item, None),
            }[action.dirkind]
        if action.min_args > 1 :
            to_parse = to_parse(items.pop(0))
        #end if
        for item in items :
            yield (action.include_matching, parse_wildcard(*to_parse(item)))
        #end for
    #end for
#end parse_filters

#+
# Definitions of valid commands.
#
# Each command function is passed two arguments: the first is
# the list of positional arguments, and the second is the
# dictionary of option keywords and corresponding values
# that were specified.
#-

def cmd_help(args, opts) :
    "shows the user the help description for a command, or for the help" \
    " command itself if no valid command is given."
    command_candidates = None
    command_match = None
    if len(args) == 1 :
        cmd = args[0]
        if cmd not in recognized_commands :
            command_match = cmd
            cmd = None
            command_candidates = list \
              (
                c for c in recognized_commands.keys()
                if fnmatch.fnmatch(c, command_match)
              )
        #end if
    else :
        cmd = "help"
        command_candidates = recognized_commands.keys()
    #end if
    if cmd != None :
        sys.stderr.write \
          (
                "Usage:\n\n\t%s %s %s\n\n%s.\n"
            %
                (
                    sys.argv[0],
                    cmd,
                    recognized_commands[cmd]["help_usage"],
                    recognized_commands[cmd]["help_descr"],
                )
          )
    #end if
    if command_candidates != None :
        if len(command_candidates) != 0 :
            sys.stderr.write \
              (
                    "\nValid commands%(matching)s are: %(commands)s.\n"
                %
                    {
                        "matching" :
                            ["", " matching \"%s\"" % command_match][command_match != None],
                        "commands" : ", ".join(sorted(command_candidates)),
                    }
              )
        else :
            sys.stderr.write("No commands matching \"%s\".\n" % command_match)
        #end if
    #end if
#end cmd_help

def cmd_init(args, opts) :
    dbname, = args
    if os.path.isfile(dbname) :
        raise getopt.GetoptError("versions file “%s” already exists" % dbname)
    #end if
    db = open_db(dbname, DB_OPEN.READWRITECREATE)
    db.close()
#end cmd_init

def cmd_setfilters(args, opts) :
    dbname, filter_filename = args
    filters = parse_manifest(open(filter_filename, "rt").read())
    sys.stdout.write("parsed manifest = %s\n" % repr(filters)) # debug
    db = open_db(dbname, DB_OPEN.READWRITE)
    cu = db.cursor()
    cu.execute("begin transaction")
    for table in ("filter_item", "filter_rule") :
        cu.execute("delete from %s" % table)
    #end for
    rule_index = 0
    for items in filters :
        rule_index += 1
        action = items.pop(0)
        cu.execute \
          (
                "insert into filter_rule(ordering, action) values(%d, %s)"
            %
                (rule_index, sqlite.format_sql_value(action))
          )
        item_index = 0
        for item in items :
            item_index += 1
            cu.execute \
              (
                    "insert into filter_item(rule_ordering, item_ordering, pathspec)"
                    " values (%d, %d, %s)"
                %
                    (rule_index, item_index, sqlite.format_sql_value(item))
              )
        #end for
    #end for
    cu.execute("end transaction")
    cu.close()
    db.close()
#end cmd_setfilters

def cmd_showfilters(args, opts) :
    dbname, = args
    db = open_db(dbname, DB_OPEN.READONLY)
    first = True
    for action, items in load_filters(db) :
        if first :
            sys.stdout.write \
              (
                "action                  items\n"
                "--------------------    -----\n"
              )
            first = False
        #end if
        sys.stdout.write \
          (
                "%-20s    %s\n"
            %
                (action, " ".join(escape_token(s) for s in items))
          )
    #end for
    if first :
        sys.stdout.write("No filter rules found.\n")
    #end if
    db.close()
#end cmd_showfilters

def cmd_list(args, opts) :
    dbname, = args
    db = open_db(dbname, DB_OPEN.READONLY)
    first = True
    for id, comment, timestamp in db_iter \
      (
        db,
        "select id, comment, timestamp from snapshots order by timestamp"
      ) \
    :
        if first :
            sys.stdout.write \
              (
                "id          when              comment\n"
                "---  -------------------  ----------------\n"
              )
            first = False
        #end if
        sys.stdout.write \
          (
                "%0.3d  %s  %s\n"
            %
                (id, time.strftime("%Y-%m-%d %H-%M-%S", time.localtime(round(timestamp))), comment)
          )
    #end for
    if first :
        sys.stdout.write("No saved snapshots found.\n")
    #end if
    db.close()
#end cmd_list

def cmd_save(args, opts) :
    dbname, basedir = args
    if not stat.S_ISDIR(os.lstat(basedir).st_mode) :
        raise ValueError("not a directory: “%s”" % basedir)
    #end if
    message = opts.get("message", "")
    db = open_db(dbname, DB_OPEN.READWRITE)
    rules = list(parse_filters(db))
    if len(rules) == 0 :
        raise ValueError("no rules specifying what to save")
    #end if
    def get_files(dirname, basename) :
        result = []
        for item in os.listdir(dirname) :
            childitem = os.path.join(dirname, item)
            childname = os.path.join(basename, item)
            info = os.lstat(childitem)
            if stat.S_ISREG(info.st_mode) :
                i = len(rules)
                while True :
                    if i == 0 :
                        includeit = False
                        break
                    #end if
                    i -= 1
                    do_include, matching = rules[i]
                    if matching.search(childname) != None :
                        includeit = do_include
                        break
                    #end if
                #end while
                if includeit :
                    result.append({"path" : childname, "timestamp" : info.st_mtime})
                #end if
            elif stat.S_ISDIR(info.st_mode) :
                result.extend(get_files(childitem, childname))
            #end if
        #end for
        return result
    #end get_files
    to_save = get_files(basedir, "")
    sys.stdout.write("files to save: %s\n" % repr(to_save)) # debug
    if len(to_save) == 0 :
        raise ValueError("no matching files to save")
    #end if
    cu = db.cursor()
    cu.execute("begin transaction")
    snaptime = time.time()
    cu.execute \
      (
            "insert into snapshots(comment, timestamp) values(%s, %s)"
        %
            (sqlite.format_sql_value(message), str(snaptime))
      )
    snapid, = list(db_iter
      (
        db,
        "select last_insert_rowid()",
        mapfn = lambda x : x[0]
      ))
    for item in to_save :
        sys.stdout.write("save %s\n" % item["path"])
        contents = open(os.path.join(basedir, item["path"]), "rb").read()
        cu.execute \
          (
                "insert into files(snapshot_id, path, timestamp, contents) values(%d, %s, %s, %s)"
            %
                (
                    snapid,
                    sqlite.format_sql_value(item["path"]),
                    str(item["timestamp"]),
                    sqlite.format_sql_value(contents),
                )
          )
    #end for
    cu.execute("end transaction")
    cu.close()
    db.close()
    sys.stdout.write \
      (
        "%d files saved in snapshot ID %d\n" % (len(to_save), snapid)
      )
#end cmd_save

def cmd_restore(args, opts) :
    dbname, snapid, destdir = args
    snapid = int(snapid)
    preserve_timestamps = "preserve-timestamps" in opts
    overwrite = "overwrite" in opts
    db = open_db(dbname, DB_OPEN.READONLY)
    if not stat.S_ISDIR(os.lstat(destdir).st_mode) :
        raise ValueError("not a directory: “%s”" % basedir)
    #end if
    if next(db_iter(db, "select id from snapshots where id = %d" % snapid), None) == None :
        raise ValueError("no such snapshot with ID %d" % snapid)
    #end if
    nr_restored = 0
    for childname, timestamp, contents in db_iter \
      (
        db,
            "select files.path, files.timestamp, files.contents from snapshots"
            " inner join files on snapshots.id = files.snapshot_id where snapshots.id = %d"
        %
            snapid
      ) \
    :
        sys.stdout.write("restore %s\n" % childname)
        childpath = os.path.join(destdir, childname)
        if not overwrite and os.path.exists(childpath) :
            raise FileExistsError("dest file “%s” already exists in %s" % (childname, destdir))
        #end if
        os.makedirs(os.path.split(childpath)[0], exist_ok = True)
        childfile = open(childpath, "wb")
        childfile.write(contents)
        childfile.close()
        if preserve_timestamps :
            os.utime(childpath, (timestamp, timestamp))
        #end if
        nr_restored += 1
    #end for
    db.close()
    sys.stdout.write("%d files restored.\n" % nr_restored)
#end cmd_restore

recognized_commands = \
    {
# key is command name, value is dictionary with following fields:
#     args -- nr required positional args, or tuple of min and max nr required positional args
#     opts -- tuple of long option names. If a name ends in an equal sign, then it takes a value.
#     multivalued -- optional tuple of option keywords which can occur multiple times
#     required -- optional tuple of option keywords which must be present
#     help_usage -- used to construct a usage string when giving help for the command.
#     help_descr -- explanatory text shown when giving help for the command.
#     action -- the function to invoke to actually perform the command.

        "help" :
            {
                "args" : (0, 1),
                "opts" : (),
                "action" : cmd_help,
                "help_usage" : "[cmd]",
                "help_descr" : "gives help about the specified command",
            },

        "init" :
            {
                "args" : 1,
                "opts" : (),
                "action" : cmd_init,
                "help_usage" : "«dbname»",
                "help_descr" : "initializes a snapshot database with the specified name",
            },

        "setfilters" :
            {
                "args" : 2,
                "opts" : (),
                "action" : cmd_setfilters,
                "help_usage" : "«dbname» «filters_file»",
                "help_descr" :
                    "parses «filters_file» and sets the filters for snapshot database «dbname»",
            },

        "showfilters" :
            {
                "args" : 1,
                "opts" : (),
                "action" : cmd_showfilters,
                "help_usage" : "«dbname»",
                "help_descr" : "shows the current snapshot filters for «dbname»",
            },

        "list" :
            {
                "args" : 1,
                "opts" : (),
                "action" : cmd_list,
                "help_usage" : "«dbname»",
                "help_descr" : "lists currently-saved snapshots in «dbname»",
            },

        "save" :
            {
                "args" : 2,
                "opts" : ("message/m=",),
                "action" : cmd_save,
                "help_usage" : "[--message=«message»] «dbname» «base_dir»",
                "help_descr" :
                    "saves a snapshot of files from «base_dir» into «dbname»"
                    " according to its currently loaded filter rules",
            },

        "restore" :
            {
                "args" : 3,
                "opts" : ("overwrite/o", "preserve-timestamps/p",),
                "action" : cmd_restore,
                "help_usage" : "«dbname» «snapid» «dest_dir»",
                "help_descr" : "restores a previously-saved snapshot into a specified directory",
            },

    } # recognized_commands

#+
# Mainline
#-

def mainline() :
    if len(sys.argv) < 2 :
        raise getopt.GetoptError("need at least one arg, the cmd to execute")
    #end if
    cmd = sys.argv[1]
    cmd_entry = recognized_commands.get(cmd)
    if cmd_entry == None :
        raise getopt.GetoptError("unrecognized command %s" % repr(cmd))
    #end if
    short_opts = {}
    long_opts = []
    for opt in cmd_entry["opts"] :
        if "/" in opt :
            has_value = opt.endswith("=")
            long_opt, short_opt = opt[:len(opt) - has_value].split("/", 1)
            if len(short_opt) != 1 :
                raise RuntimeError("invalid short opt for %s" % repr(opt))
            #end if
            short_opts[short_opt] = {"long_opt" : long_opt, "has_value" : has_value}
            long_opts.append(long_opt + ("", "=")[has_value])
        else :
            long_opts.append(opt)
        #end if
    #end for
    sys.stderr.write("short opts = %s, long opts = %s\n" % (repr("".join(k + ("", ":")[short_opts[k]["has_value"]] for k in short_opts)), repr(long_opts))) # debug
    opts_list, args = getopt.gnu_getopt \
      (
        sys.argv[2:],
        "".join(k + ("", ":")[short_opts[k]["has_value"]] for k in short_opts),
        long_opts
      )
    if type(cmd_entry["args"]) == tuple :
        if \
          (
                len(args) < cmd_entry["args"][0]
            or
                len(args) > cmd_entry["args"][1]
          ):
            raise getopt.GetoptError \
              (
                "%s command needs %u..%u args" % ((cmd,) + cmd_entry["args"])
              )
        #end if
    else :
        if len(args) != cmd_entry["args"] :
            raise getopt.GetoptError \
              (
                "%s command needs exactly %u args" % (cmd, cmd_entry["args"])
              )
        #end if
    #end if
    opts = {}
    multi_opts = frozenset(cmd_entry.get("multivalued", ()))
    for keyword, value in opts_list :
        if keyword[:2] == "--" :
            opt = keyword[2:]
        elif keyword[:1] == "-" :
            opt = short_opts[keyword[1:]]["long_opt"]
        else :
            raise RuntimeError("unrecognized keyword %s" % repr(keyword))
        #end if
        if opt in multi_opts :
            values = opts.get(opt, [])
            values.append(value)
            opts[opt] = values
        else :
            opts[opt] = value
        #end if
    #end for
    required_opts = cmd_entry.get("required")
    if required_opts != None :
        missing = set(required_opts) - set(opts.keys())
        if len(missing) != 0 :
            raise getopt.GetoptError \
              (
                "%s command needs option(s) %s" % (cmd, ",".join(tuple(missing)))
              )
        #end if
    #end if
    cmd_entry["action"](args, opts) # can raise exceptions
#end mainline

mainline()
